use std::evm
use std::buf::{
    MemoryBuffer, 
    RawCallBuffer,
    MemoryBufferWriter,
    MemoryBufferReader
}

contract Store {
    // Simple binary interface for reading and writing to contract state.
    // 
    // For reads, the interface is defined as:
    //
    // input: selector (32 bytes), key (dynamic)
    // output: value (dynamic) 
    //
    // For writes, the interface is defined as:
    // 
    // input: selector (32 bytes), key length (32 bytes), key (dynamic), value (dynamic)
    //
    // note: at this point the value being stored is fixed to 32.
    //
    // todos: 
    //  - change selector to a single byte
    //  - proper output lengths
    pub unsafe fn __call__() {
        // 0 for read; 1 for write
        let selector: u256 = evm::call_data_load(offset: 0)

        if selector == 0 {
            let key_len: u256 = evm::call_data_size() - 32
            let mut key_buf: MemoryBuffer = MemoryBuffer::new(len: key_len)
            evm::call_data_copy(buf: key_buf, from_offset: 32)
            let slot_offset: u256 = std::precompiles::sha2_256(buf: key_buf)
            let slot_value: u256 = evm::sload(offset: slot_offset)

            // how do we know the size of the read data?
            let mut return_buf: MemoryBuffer = MemoryBuffer::new(len: 32)
            let mut return_writer: MemoryBufferWriter = return_buf.writer()
            return_writer.write(value: slot_value)

            evm::return_mem(buf: return_buf)
        } else {
            let key_len: u256 = evm::call_data_load(offset: 32)
            let mut key_buf: MemoryBuffer = MemoryBuffer::new(len: key_len)
            evm::call_data_copy(buf: key_buf, from_offset: 64)
            let slot_offset: u256 = std::precompiles::sha2_256(buf: key_buf)

            // assume length of 32 
            // let data_len: u256 = evm::call_data_size() - 64 - key_len
            // let data_buf: MemoryBuffer = MemoryBuffer::new(len: data_len)
            let data_value: u256 = evm::call_data_load(offset: 64 + key_len)
            evm::sstore(offset: slot_offset, value: data_value)
        }
    }
}

struct StoreAccessor {
    addr: address

    pub fn new(addr: address) -> Self {
        return StoreAccessor(addr)
    }

    pub fn read(self, key: u256) -> u256 {
        let mut buf: RawCallBuffer = RawCallBuffer::new(input_len: 64, output_len: 32)

        let mut writer: MemoryBufferWriter = buf.writer()
        let mut reader: MemoryBufferReader = buf.reader()

        writer.write(value: 0) // read selector
        writer.write(value: key)

        unsafe { 
            assert evm::call(gas: evm::gas_remaining(), addr: self.addr, value: 0, buf) 
        }

        return reader.read_u256()
    }

    pub fn write(self, key: u256, value: u256) {
        let mut buf: RawCallBuffer = RawCallBuffer::new(input_len: 128, output_len: 0)

        let mut writer: MemoryBufferWriter = buf.writer()
        writer.write(value: 1) // write selector
        writer.write(value: 32) // 32 byte key
        writer.write(value: key)
        writer.write(value)

        unsafe { 
            assert evm::call(gas: evm::gas_remaining(), addr: self.addr, value: 0, buf) 
        }
    }
}

#test
fn test_store_rw(mut ctx: Context) {
    let addr: address = address(Store.create(ctx, 0))
    let accessor: StoreAccessor = StoreAccessor::new(addr)

    assert accessor.read(key: 42) == 0
    accessor.write(key: 42, value: 23)
    assert accessor.read(key: 42) == 23
}
