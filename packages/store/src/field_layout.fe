use std::evm
use constants::{WORD_SIZE, WORD_LAST_INDEX, BYTE_TO_BITS, MAX_TOTAL_FIELDS, MAX_DYNAMIC_FIELDS}

struct FieldLayoutLib_InvalidLength {
    pub length: u256
}
struct FieldLayoutLib_StaticLengthIsZero {
}
struct FieldLayoutLib_StaticLengthDoesNotFitInAWord {
}

pub struct FieldLayout {
    inner: u256

    pub fn encode(staticFields: Array<u256, 28>, numStaticFields: u256, numDynamicFields: u256) -> Self {
        let mut fieldLayout: u256
        let mut totalLength: u256
        let totalFields: u256 = numStaticFields + numDynamicFields;

        if numStaticFields > MAX_TOTAL_FIELDS {
            // TODO remove the need for numStaticFields by using a dynamic array
            revert FieldLayoutLib_InvalidLength(length: numStaticFields)
        }

        if totalFields > MAX_TOTAL_FIELDS {
            revert FieldLayoutLib_InvalidLength(length: totalFields)
        }
        if numDynamicFields > MAX_DYNAMIC_FIELDS {
            revert FieldLayoutLib_InvalidLength(length: numDynamicFields)
        }

        // Compute the total static length and store the field lengths in the encoded fieldLayout
        let mut i: u256 = 0
        while (i < numStaticFields) {
            let staticByteLength: u256 = staticFields[i]

            if staticByteLength == 0 {
                revert FieldLayoutLib_StaticLengthIsZero()
            } else if staticByteLength > WORD_SIZE {
                revert FieldLayoutLib_StaticLengthDoesNotFitInAWord()
            }

            totalLength += staticByteLength
            fieldLayout |= staticByteLength << ((WORD_LAST_INDEX - 4 - i) * BYTE_TO_BITS)

            i += 1
        }

        return FieldLayout(inner: fieldLayout)
    }

    pub fn atIndex(
        self, 
        index: u256
    ) -> u256 {
        return u8(self.inner >> ((WORD_LAST_INDEX - 4 - index) * BYTE_TO_BITS))
    }
}

#test
fn test_field_layout(mut ctx: Context) {
    let mut staticFields: Array<u256, 28> = [1, 2, 4, 16, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    staticFields[0] = 1
    staticFields[1] = 2
    staticFields[2] = 4
    staticFields[3] = 16
    staticFields[4] = 32
    let field_layout: FieldLayout = FieldLayout::encode(staticFields, numStaticFields: 5, numDynamicFields: 1)

    assert field_layout.atIndex(index: 0) == 1
    assert field_layout.atIndex(index: 1) == 2
    assert field_layout.atIndex(index: 2) == 4
    assert field_layout.atIndex(index: 3) == 16
    assert field_layout.atIndex(index: 4) == 32
    assert field_layout.atIndex(index: 5) == 0
}
